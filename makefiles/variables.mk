# Copyright 2025 Leon Hwang.
# SPDX-License-Identifier: Apache-2.0


CMD_BPFTOOL ?=
CMD_CC ?= clang
CMD_CD ?= cd
CMD_CHECKSUM ?= sha256sum
CMD_CP ?= cp
CMD_CXX ?= clang++
CMD_IP ?= ip
CMD_GH ?= gh
CMD_MV ?= mv
CMD_TAR ?= tar
CMD_GIT ?= git
CMD_GIT_MODULES ?= $(CMD_GIT) submodule

ifeq ($(CMD_BPFTOOL),)
	# Debian-based distros install bpftool to /usr/sbin/ which is only in root user's PATH
	CMD_BPFTOOL := $(shell PATH="$$PATH:/usr/local/sbin:/usr/sbin:/sbin" which bpftool)
	ifeq ($(CMD_BPFTOOL),)
		CMD_BPFTOOL := bpftool
	endif
endif

UNAME_ARCH := $(shell uname -m)
GCC_LIB_DIR := /usr/lib/gcc/$(UNAME_ARCH)-linux-gnu/$(shell gcc -dumpversion | cut -d. -f1)

CPU_CORES := $(shell (command -v nproc >/dev/null 2>&1 && nproc) \
		|| grep -E '^processor' /proc/cpuinfo | wc -l)

DIR_BIN := ./bin

# No `./' here to match rules generated by bpf2go
DIR_BPF := internal/bpf

GOBUILD := go build -v -trimpath
GOBUILD_CGO_CFLAGS := CGO_CFLAGS='-O2 -I$(CURDIR)/lib/capstone/include -I$(CURDIR)/lib/libpcap'
GOBUILD_CGO_LDFLAGS := CGO_LDFLAGS='-O2 -g -L$(CURDIR)/lib/capstone/build -lcapstone -L$(CURDIR)/lib/libpcap -lpcap -static'

ifeq ($(UNAME_ARCH),x86_64)
	TARGET_ARCH := x86
else ifeq ($(UNAME_ARCH),aarch64)
	TARGET_ARCH := arm64
else
	$(error Unsupported architecture: $(UNAME_ARCH).)
endif

GO_RUN_BPF2GO := go run github.com/cilium/ebpf/cmd/bpf2go -cc clang
BPF2GO_EXTRA_FLAGS := -g -D__TARGET_ARCH_$(TARGET_ARCH) -I$(CURDIR)/bpf -I$(CURDIR)/bpf/headers -I$(CURDIR)/lib/libbpf/src -Wno-address-of-packed-member -Wall

# We must split this into multiple macros as $(call ...) is a simple template expansion.
# That is, variable assignments won't be visible until $(eval ...) is called.
define gen_bpf2go_vars1
	stem := $(word 1,$(subst =, ,$1))
	obj := $(shell echo "$(word 1,$(subst =, ,$1))" | tr '[[:upper:]]' '[[:lower:]]')
	src := $(word 2,$(subst =, ,$1))
endef
define gen_bpf2go_vars2
	ifeq ($(src),)
		src := $(obj)
	endif
endef
define gen_bpf2go_vars3
	BPF_OBJ += $(DIR_BPF)/$(obj)_bpfel.o $(DIR_BPF)/$(obj)_bpfeb.o
	MAP_OBJ_TO_STEM__$(obj) := $(stem)

	BPF_SRC += bpf/$(src).c
	MAP_OBJ_TO_SRC__$(obj) := $(src)
endef

BPF2GO_MAP := Bpfsnoop Read Traceable Tracepoint Tracepoint_module Tailcall \
	Feat=feature Graph=bpfsnoop_fgraph Insn=bpfsnoop_insn Kmulti=bpfsnoop_kmulti

$(foreach ent,$(BPF2GO_MAP),\
	$(eval $(call gen_bpf2go_vars1,$(ent))) \
	$(eval $(call gen_bpf2go_vars2)) \
	$(eval $(call gen_bpf2go_vars3)))

BPF_GO_SRC := $(BPF_OBJ:%.o=%.go)
BPF_GO_DEP := $(BPF_GO_SRC:%=%.d)

# Dependency rules generated by bpf2go -makebase
-include $(BPF_GO_DEP)

BPFSNOOP_OBJ := bpfsnoop
BPFSNOOP_SRC := $(shell find internal -type f -name '*.go') main.go
BPFSNOOP_CSM := $(BPFSNOOP_OBJ).sha256sum
RELEASE_NOTES ?= release_notes.txt

# Do our best to detect changes in submodules and rebuild them...
LIBCAPSTONE_DIR := lib/capstone
LIBCAPSTONE_SRC := $(LIBCAPSTONE_DIR) \
	$(shell find $(LIBCAPSTONE_DIR) -type f -name '*.[ch]' 2>/dev/null)
LIBCAPSTONE_OBJ := $(LIBCAPSTONE_DIR)/build/libcapstone.a

LIBPCAP_DIR := lib/libpcap
LIBPCAP_SRC := $(LIBPCAP_DIR) \
	$(shell find $(LIBPCAP_DIR) -type f -name '*.[ch]' 2>/dev/null)
LIBPCAP_OBJ := $(LIBPCAP_DIR)/libpcap.a

LIBBPF_OBJ := lib/libbpf/src

VMLINUX_OBJ := bpf/headers/vmlinux.h
VMLINUX_SRC := /sys/kernel/btf/vmlinux

GIT_MODULES_DIR := .git/modules

LOCALTEST_OBJ := localtest
LOCALTEST_SRC := $(shell find ./cmd/localtest/ -type f -name '*.go')

XDPCRC_DIR := ./cmd/xdpcrc
XDPCRC_BPF_OBJ := $(XDPCRC_DIR)/xdp_bpfel.o $(XDPCRC_DIR)/xdp_bpfeb.o
XDPCRC_BPF_OBJ += $(XDPCRC_BPF_OBJ:%.o=%.go)
XDPCRC_OBJ := xdpcrc
XDPCRC_SRC := $(wildcard $(XDPCRC_DIR)/*.go $(XDPCRC_DIR)/*.c)
